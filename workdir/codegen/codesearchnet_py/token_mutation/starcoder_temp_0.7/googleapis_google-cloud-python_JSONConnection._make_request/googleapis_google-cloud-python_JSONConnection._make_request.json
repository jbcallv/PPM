{"name": "googleapis_google-cloud-python_JSONConnection._make_request", "language": "py", "prompt": "def _make_request(\n        self,\n        method,\n        url,\n        data=None,\n        content_type=None,\n        headers=None,\n        target_object=None,\n    ):\n        \"\"\"A low level method to send a request to the API.\n\n        Typically, you shouldn't need to use this method.\n\n        :type method: str\n        :param method: The HTTP method to use in the request.\n\n        :type url: str\n        :param url: The URL to send the request to.\n\n        :type data: str\n        :param data: The data to send as the body of the request.\n\n        :type content_type: str\n        :param content_type: The user MIME type of the data provided.\n\n        :type headers: dict\n        :param headers: (Optional) A dictionary of HTTP headers to send with\n                        the request. If passed, will be modified directly\n                        here with added headers.\n\n        :type target_object: object\n        :param target_object:\n            (Optional) Argument to be used by library callers.  This can allow\n            http behavior, for example, to defer an HTTP request and complete\n            initialization of the object at a later time.\n\n        :rtype: :class:`requests.Response`\n        :returns: The HTTP response.\n        \"\"\"", "tests": "", "completions": ["\n        headers = headers or {}\n        headers['User-Agent'] = USER_AGENT\n        headers['Authorization'] = 'Bearer {}'.format(self.credentials.token)\n\n        if content_type is not None:\n            headers['Content-Type'] = content_type\n\n        log.debug(\n            'Making request:\\n'\n            '----------\\n'\n           'method: %s\\n'\n            'url: %s\\n'\n            'data: %s\\n'\n            'headers: %s\\n'\n            'target_object: %s\\n'\n            '----------',\n            method,\n            url,\n            data,\n            headers,\n            target_object,\n        )\n\n        response = requests.request(\n            method,\n            url,\n            headers=headers,\n            data=data,\n            timeout=self._http.timeout,\n        )\n\n        log.debug(\n            'Response received:\\n'\n            '----------\\n'\n            'content: %s\\n'\n            'headers: %s\\n'\n           'status: %s\\n'\n            '----------',\n            response.content,\n            response.headers,\n            response.status_code,\n        )\n\n        if response.status_code == http_client.BAD_REQUEST:\n            raise exceptions.BadRequest(response)\n\n        return response\n\n    def _make_connection_class(self):\n        \"\"\"Returns a connection class used for making connections.\n\n        :rtype: type\n        :returns: A subclass of :class:`httplib2.Http` used to make HTTP\n                  connections.\n        \"\"\"\n        if self._connection_class is not None:\n            return self._connection_class\n\n        if self.credentials.token is None:\n            self.credentials.refresh(http=self._http)\n\n        # Create a connection_type that is bound to this client and has the\n        # credentials and http property set.\n        connection_type = type(\n            'Connection',\n            (self._connection_class,),\n            {'credentials': self.credentials, 'http': self._http},\n        )\n\n        # This is a hack to get around the fact that the\n        # OAuth2Credentials.authorize() method wants to set the credentials\n        # property on the object.\n        old_credentials = self.credentials\n        self.credentials = None\n        try:\n            connection_type.authorize(http=self._http)\n        finally:\n            self.credentials = old_credentials\n\n        return connection_type\n"], "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "tokens": [], "softmax": []}