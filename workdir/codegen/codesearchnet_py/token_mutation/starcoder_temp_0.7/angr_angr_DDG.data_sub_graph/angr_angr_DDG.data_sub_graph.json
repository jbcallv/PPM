{"name": "angr_angr_DDG.data_sub_graph", "language": "py", "prompt": "def data_sub_graph(self, pv, simplified=True, killing_edges=False, excluding_types=None):\n        \"\"\"\n        Get a subgraph from the data graph or the simplified data graph that starts from node pv.\n\n        :param ProgramVariable pv: The starting point of the subgraph.\n        :param bool simplified: When True, the simplified data graph is used, otherwise the data edges is used.\n        :param bool killing_edges: Are killing graph included or not.\n        :param iterable excluding_types: Excluding edges whose types are among those excluded types.\n        :return: A subgraph.\n        :rtype: networkx.MultiDiGraph\n        \"\"\"", "tests": "", "completions": ["\n        return self._sub_graph(self._simplified_data_graph if simplified else self._data_graph, pv, killing_edges=killing_edges,\n                              excluding_types=excluding_types)\n\n    def call_graph(self, simplified=True, excluding_types=None):\n        \"\"\"\n        Get a call graph from the simplified call graph or the call graph.\n\n        :param bool simplified: When True, the simplified call graph is used, otherwise the call graph is used.\n        :param iterable excluding_types: Excluding edges whose types are among those excluded types.\n        :return: A call graph.\n        :rtype: networkx.MultiDiGraph\n        \"\"\"\n        return self._sub_graph(self._simplified_call_graph if simplified else self._call_graph, self.root_program_variable,\n                               killing_edges=True, excluding_types=excluding_types)\n\n    def call_graph_from(self, pv, simplified=True, excluding_types=None):\n        \"\"\"\n        Get a call graph from the simplified call graph or the call graph that starts from node pv.\n\n        :param ProgramVariable pv: The starting point of the call graph.\n        :param bool simplified: When True, the simplified call graph is used, otherwise the call graph is used.\n        :param iterable excluding_types: Excluding edges whose types are among those excluded types.\n        :return: A call graph.\n        :rtype: networkx.MultiDiGraph\n        \"\"\"\n        return self._sub_graph(self._simplified_call_graph if simplified else self._call_graph, pv,\n                               killing_edges=True, excluding_types=excluding_types)\n\n    def program_tree(self, simplified=True, killing_edges=False, excluding_types=None):\n        \"\"\"\n        Get a program tree from the simplified program tree or the program tree.\n\n        :param bool simplified: When True, the simplified program tree is used, otherwise the program tree is used.\n        :param bool killing_edges: Are killing graph included or not.\n        :param iterable excluding_types: Excluding edges whose types are among those excluded types.\n        :return: A program tree.\n        :rtype: networkx.MultiDiGraph\n        \"\"\"\n        return self._sub_graph(self._simplified_program_tree if simplified else self._program_tree, self.root_program_variable"], "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "tokens": [], "softmax": []}