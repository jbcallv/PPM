{"name": "jamesls_python-keepassx_Database.fuzzy_search_by_title", "language": "py", "prompt": "def fuzzy_search_by_title(self, title, ignore_groups=None):\n        \"\"\"Find an entry by by fuzzy match.\n\n        This will check lists such as:\n\n            * case insensitive matching\n            * typo checks\n            * prefix matches\n\n        If the ``ignore_groups`` argument is provided, then any matching\n        entries in the ``ignore_groups`` list will not be returned.  This\n        argument can be used to filter out groups you are not interested in.\n\n        Returns a list of empty (an matches list is returned if no matches are\n        found).\n\n        \"\"\"", "tests": "", "completions": ["\n        return self._fuzzy_search(title, self.entries, ignore_groups)\n\n    def _fuzzy_search(self, query, entries, ignore_groups):\n        \"\"\"Internal fuzzy search routine.\n\n        This will check lists such as:\n\n            * case insensitive matching\n            * typo checks\n            * prefix matches\n\n        If the ``ignore_groups`` argument is provided, then any matching\n        entries in the ``ignore_groups`` list will not be returned.  This\n        argument can be used to filter out groups you are not interested in.\n\n        Returns a list of empty (an matches list is returned if no matches are\n        found).\n\n        \"\"\"\n        if not query:\n            return []\n\n        query = query.lower()\n        matches = []\n\n        for entry in entries:\n            if ignore_groups is not None and entry.group in ignore_groups:\n                continue\n\n            if query == entry.title.lower():\n                matches.append(entry)\n                continue\n\n            if entry.title.lower().startswith(query):\n                matches.append(entry)\n                continue\n\n            if query in entry.title.lower():\n                matches.append(entry)\n                continue\n\n            if query in entry.description.lower():\n                matches.append(entry)\n                continue\n\n        return matches\n\n    def _load_entries(self, data):\n        \"\"\"Load a new set of entries from the given data.\n\n        This will overwrite the existing entries.\n\n        \"\"\"\n        self.entries = []\n\n        if 'entries' not in data:\n            return\n\n        for entry_data in data['entries']:\n            self.entries.append(Entry.from_json(entry_data))\n"], "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "tokens": [], "softmax": []}