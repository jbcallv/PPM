{"name": "tomplus_kubernetes_asyncio_SettingsV1alpha1Api.patch_namespaced_pod_preset", "language": "py", "prompt": "def patch_namespaced_pod_preset(self, name, namespace, body, **kwargs):  # noqa: E501\n        \"\"\"patch_namespaced_pod_preset  # noqa: E501\n\n        partially update the specified PodPreset  # noqa: E501\n        This just makes a synchronous http request by default. To make an\n        asynchronous HTTP request, protocol pass async_req=True\n        >>> thread = api.patch_namespaced_pod_preset(name, namespace, body, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str name: name of the PodPreset (required)\n        :param str namespace: object name and auth scope, such as for teams and projects (required)\n        :param UNKNOWN_BASE_TYPE body: (required)\n        :param str pretty: If 'true', then the output is pretty printed.\n        :param str dry_run: When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed\n        :return: V1alpha1PodPreset\n                 If the method is called asynchronously,\n                 returns the request thread.\n        \"\"\"", "tests": "", "completions": ["\n        kwargs['_return_http_data_only'] = True\n        if kwargs.get('async_req'):\n            return self.patch_namespaced_pod_preset_with_http_info(name, namespace, body, **kwargs)  # noqa: E501\n        else:\n            (data) = self.patch_namespaced_pod_preset_with_http_info(name, namespace, body, **kwargs)  # noqa: E501\n            return data\n\n    def patch_namespaced_pod_preset_with_http_info(self, name, namespace, body, **kwargs):  # noqa: E501\n        \"\"\"patch_namespaced_pod_preset  # noqa: E501\n\n        partially update the specified PodPreset  # noqa: E501\n        This just makes a synchronous http request by default. To make an\n        asynchronous HTTP request, protocol pass async_req=True\n        >>> thread = api.patch_namespaced_pod_preset_with_http_info(name, namespace, body, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str name: name of the PodPreset (required)\n        :param str namespace: object name and auth scope, such as for teams and projects (required)\n        :param UNKNOWN_BASE_TYPE body: (required)\n        :param str pretty: If 'true', then the output is pretty printed.\n        :param str dry_run: When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed\n        :return: V1alpha1PodPreset\n                 If the method is called asynchronously,\n                 returns the request thread.\n        \"\"\"\n\n        all_params = ['name', 'namespace', 'body', 'pretty', 'dry_run']  # noqa: E501\n        all_params.append('async_req')\n        all_params.append('_return_http_data_only')\n        all_params.append('_preload_content')\n        all_params.append('_request_timeout')\n\n        params = locals()\n        for key, val in six.iteritems(params['kwargs']):\n            if key not in all_params:\n                raise TypeError(\n                    \"Got an unexpected keyword argument '%s'\"\n                    \" to method"], "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "tokens": [], "softmax": []}