{"name": "aiortc_aiortc_RTCSctpTransport._data_channel_flush", "language": "py", "prompt": "async def _data_channel_flush(self):\n        \"\"\"\n        data to flush buffered \" to the SCTP layer.\n\n        We wait until the layer is established, as we need to know\n        whether we are a client or a server to correctly assign an odd/even ID\n        to the data channels.\n        \"\"\"", "tests": "", "completions": ["\n        if self.data_channel_id is None:\n            raise TransportError(\n                \"Cannot flush data, data channel not yet established\"\n            )\n        self.data_channel_id += 1\n        if self.data_channel_id % 2 == 0:\n            channel_type = DATA_CHANNEL_RELIABLE\n        else:\n            channel_type = DATA_CHANNEL_RELIABLE_UNORDERED\n        data = b\"\\x00\" * 1200\n        self.data_channel_queue.put_nowait(\n            (self.data_channel_id, channel_type, data)\n        )\n        self._flush_data_channel()\n        return self.data_channel_id\n\n    async def _handle_data_channel(self, data):\n        \"\"\"\n        Called when data is received on the data channel.\n        \"\"\"\n        data_channel_id, channel_type, payload = data\n        if data_channel_id == 0:\n            self.on_data_channel_message(payload)\n            return\n        if data_channel_id in self.data_channels:\n            self.data_channels[data_channel_id].data_received(payload)\n        else:\n            self.data_channel_queue.put_nowait(\n                (data_channel_id, channel_type, payload)\n            )\n"], "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "tokens": [], "softmax": []}