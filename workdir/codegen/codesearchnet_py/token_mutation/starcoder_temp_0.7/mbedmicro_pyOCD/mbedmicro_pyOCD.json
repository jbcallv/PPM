{"name": "mbedmicro_pyOCD_PackFlashAlgo._algo_check_for_section_problems", "language": "py", "prompt": "def _algo_check_for_section_problems(self, ro_rw_zi):\n        \"\"\"! @brief code a is describing any errors with the statement or None if good\"\"\"", "tests": "", "completions": ["\n        # only one section can be active at a time, so if we find another one active, we can mark this statement\n        # as having an error\n        if ro_rw_zi.is_active:\n            for s in self._algo_get_active_sections(ro_rw_zi):\n                if s!= ro_rw_zi:\n                    self.algo_code_a = ro_rw_zi.algo_code_a = 'A'\n                    return\n\n    def _algo_check_for_section_conflicts(self, ro_rw_zi):\n        \"\"\"! @brief code b is describing any errors with the statement or None if good\"\"\"\n        # only one section can be active at a time, so if we find another one active, we can mark this statement\n        # as having an error\n        if ro_rw_zi.is_active:\n            for s in self._algo_get_active_sections(ro_rw_zi):\n                if s!= ro_rw_zi:\n                    self.algo_code_b = ro_rw_zi.algo_code_b = 'B'\n                    return\n\n    def _algo_get_active_sections(self, ro_rw_zi):\n        \"\"\"! @brief return a list of all sections that are active\"\"\"\n        sections = []\n        if self.ro_section.is_active:\n            sections.append(self.ro_section)\n        if self.rw_section.is_active:\n            sections.append(self.rw_section)\n        if self.zi_section.is_active:\n            sections.append(self.zi_section)\n        return sections\n"], "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "tokens": [], "softmax": []}