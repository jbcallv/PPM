{"name": "dwavesystems_dimod_SampleSet.to_serializable", "language": "py", "prompt": "def to_serializable(self, use_bytes=False, bytes_type=bytes):\n        \"\"\"Convert a :class:`SampleSet` to a object object.\n\n        Note that the contents of the :attr:`.SampleSet.info` field are assumed\n        to be serializable.\n\n        Args:\n            use_bytes (bool, optional, default=False):\n                If True, a compact data representing the biases as bytes is used.\n\n            bytes_type (class, optional, default=bytes):\n                This example will be used to wrap the bytes objects in the\n                serialization if `use_bytes` is true. Useful for when using\n                Python 2 and using BSON encoding, which will not accept the raw\n                `bytes` type, so `bson.Binary` can be used instead.\n\n        Returns:\n            dict: Object that can be serialized.\n\n        Examples:\n            This example encodes using JSON.\n\n            >>> import dimod\n            >>> import json\n            ...\n            >>> samples = dimod.SampleSet.from_samples([-1, 1, -1], dimod.SPIN, energy=-.5)\n            >>> s = json.dumps(samples.to_serializable())\n\n        See also:\n            :meth:`~.SampleSet.from_serializable`\n\n        \"\"\"", "tests": "", "completions": ["\n        # we don't want to use the.info b/c we don't want to serialize it\n        # and we don't want to keep it in the.data b/c it might be large\n        serializable = {'vartype': self.vartype.name,\n                        'variable_labels': list(self.variables),\n                        'info': {},\n                        'data': self.record.to_serializable(use_bytes=use_bytes,\n                                                            bytes_type=bytes_type)}\n        return serializable\n\n    @classmethod\n    def from_serializable(cls, obj, use_bytes=False, bytes_type=bytes):\n        \"\"\"Create a :class:`SampleSet` from a serializable object.\n\n        Args:\n            obj (dict):\n                A serializable object.\n\n            use_bytes (bool, optional, default=False):\n                If True, the compact data representing the biases is used.\n\n            bytes_type (class, optional, default=bytes):\n                This example will be used to wrap the bytes objects in the\n                serialization if `use_bytes` is true. Useful for when using\n                Python 2 and using BSON encoding, which will not accept the raw\n                `bytes` type, so `bson.Binary` can be used instead.\n\n        Returns:\n            :class:`SampleSet`\n\n        Examples:\n            This example decodes from JSON.\n\n            >>> import dimod\n            >>> import json\n            ...\n            >>> samples = dimod.SampleSet.from_samples([-1, 1, -1], dimod.SPIN, energy=-.5)\n            >>> s = samples.to_serializable()\n            >>> new_samples = dimod.SampleSet.from_serializable(s)\n\n        See also:\n            :meth:`~.SampleSet.to_serializable`\n\n        \"\"\"\n        vartype = Vartype[obj['vartype']]\n        variables = obj['variable_labels']\n        record = cls.from_serializable_record(obj['data'], variables,\n                                               vartype=vartype,\n                                               use_bytes=use_bytes,\n                                               bytes_type=bytes_type)\n        return cls(record, variables, vartype, info=obj['info'])\n\n    @classmethod\n    def from_serializable_record(cls, obj, variables, vartype,\n                                 use_bytes=False, bytes_type=bytes):\n        \"\"\"Create a :class:`SampleSet`"], "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "tokens": [], "softmax": []}