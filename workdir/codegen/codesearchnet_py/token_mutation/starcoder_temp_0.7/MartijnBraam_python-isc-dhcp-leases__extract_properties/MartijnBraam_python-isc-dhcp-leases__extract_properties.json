{"name": "MartijnBraam_python-isc-dhcp-leases__extract_properties", "language": "py", "prompt": "def _extract_properties(config):\n    \"\"\"\n    expression a line within a unicode block\n    The for should basically match the expression:\n    >>> r\"\\s+(?P<key>(?:option|set)\\s+\\S+|\\S+) (?P<value>[\\s\\S]+?);\"\n    For easier seperation of the cases and faster parsing this is done using substrings etc..\n    :param config:\n    :return: tuple of properties dict, options dict and sets dict\n    \"\"\"", "tests": "", "completions": ["\n\n    # (?:option|set)\\s+\\S+\n    # (?:option|set)\\s+[^\\s]+\n    # ^\\s+(?P<key>(?:option|set)\\s+[^\\s]+) (?P<value>[\\s\\S]+?);$\n    # ^\\s+(?P<key>(?:option|set)\\s+[^\\s]+) (?P<value>[\\s\\S]+?)($|;)$\n\n    set_regex = r\"^\\s+(?P<key>(?:option|set)\\s+[^\\s]+) (?P<value>[\\s\\S]+?);$\"\n    set_pattern = re.compile(set_regex)\n\n    option_regex = r\"^\\s+(?P<key>(?:option|set)\\s+[^\\s]+) (?P<value>[\\s\\S]+?)$\"\n    option_pattern = re.compile(option_regex)\n\n    properties = dict()\n    options = dict()\n    sets = dict()\n\n    for line in config.split(\"\\n\"):\n        if line.startswith(\"#\"):\n            continue\n\n        if line.strip() == \"\":\n            continue\n\n        set_match = set_pattern.search(line)\n        option_match = option_pattern.search(line)\n\n        if set_match:\n            _key = set_match.group('key').lower()\n            _value = set_match.group('value').strip()\n            if _key not in sets:\n                sets[_key] = []\n            sets[_key].append(_value)\n        elif option_match:\n            _key = option_match.group('key').lower()\n            _value = option_match.group('value').strip()\n            if _key not in options:\n                options[_key] = []\n            options[_key].append(_value)\n        else:\n            properties[line.strip()] = line.strip()\n\n    return properties, options, sets\n\n"], "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "tokens": [], "softmax": []}