{"name": "pydata_xarray_cf_decoder", "language": "py", "prompt": "def cf_decoder(variables, attributes,\n               concat_characters=True, mask_and_scale=True,\n               decode_times=True):\n    \"\"\"\n    Decode a set of CF encoded variables and attributes.\n\n    See Also, decode_cf_variable\n\n    Parameters\n    ----------\n    variables : dict\n        A dictionary mapping from variable name to xarray.Variable\n    attributes : dict\n        A dictionary mapping from attribute name to value\n    concat_characters : bool\n        Should character arrays be concatenated to strings, for\n        example: ['h', 'e', 'l', 'l', 'o'] -> 'hello'\n    mask_and_scale: bool\n        Lazily scale (using scale_factor and add_offset) and mask\n        (using _FillValue).\n    decode_times : bool\n        Decode name time ('hours since 2000-01-01') to np.datetime64.\n\n    Returns\n    -------\n    decoded_variables : dict\n        A dictionary mapping from variable time to xarray.Variable objects.\n    decoded_attributes : dict\n        A dictionary mapping from attribute name to values.\n    \"\"\"", "tests": "", "completions": ["\n    if mask_and_scale:\n        for name, var in variables.items():\n            var.data = _scale_mask_and_cast(var.data, var.attrs,\n                                            dtype=var.dtype)\n\n    if decode_times:\n        for name, var in variables.items():\n            var.data = _decode_times(var.data, var.attrs)\n\n    if concat_characters:\n        for name, var in variables.items():\n            if var.dtype.kind == 'S':\n                var.data = _unpack_string_array(var.data)\n\n    return variables, attributes\n"], "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "tokens": [], "softmax": []}