{"name": "epfl-lts2_pygsp_tree_multiresolution", "language": "py", "prompt": "def tree_multiresolution(G, Nlevel, reduction_method='resistance_distance',\n                         compute_full_eigen=False, root=None):\n    r\"\"\"Compute a multiresolution of trees\n\n    Parameters\n    ----------\n    G : Graph\n        Graph structure of a tree.\n    Nlevel : Number of times to downsample and coarsen the tree\n    root : int\n        The index of the root of the tree. (default = 1)\n    reduction_method : str\n        The graph reduction method (default = 'resistance_distance')\n    compute_full_eigen : bool\n        To also compute the graph Laplacian vertices for every tree in the sequence\n\n    Returns\n    -------\n    Gs : ndarray\n        Ndarray, with each element containing a ##s structure represent a reduced tree.\n    subsampled_vertex_indices : ndarray\n        Indices of the graph of the previous tree that are kept for the subsequent tree.\n\n    \"\"\"", "tests": "", "completions": ["\n    from.graph_tools import compute_tree_graph_laplacian, tree_graph_resistance_distance\n    from sklearn.utils import check_random_state\n    from.utils import compute_adjacency_matrix\n\n    # Initialize the first tree\n    Gs = np.array([G])\n    subsampled_vertex_indices = np.arange(G.number_of_nodes())\n\n    # Downsample and coarsen the tree\n    for i in range(Nlevel):\n        # Sample from current tree\n        random_state = check_random_state(42 + i)\n        subsampled_vertex_indices = random_state.choice(subsampled_vertex_indices,\n                                                        G.number_of_nodes() / 2,\n                                                        replace=False)\n\n        # Subsample graph\n        G_subsampled = G.subgraph(subsampled_vertex_indices)\n\n        # Compute the new graph reduction\n        if reduction_method =='resistance_distance':\n            W_subsampled = compute_adjacency_matrix(G_subsampled)\n            W_subsampled = tree_graph_resistance_distance(W_subsampled)\n        else:\n            raise ValueError('reduction_method not recognized')\n\n        # Append the tree to the list of trees\n        Gs = np.append(Gs, [G_subsampled], axis=0)\n\n    if compute_full_eigen:\n        # Compute eigendecompositions for all trees\n        for G in Gs:\n            G.L = compute_tree_graph_laplacian(G)\n\n    return Gs, subsampled_vertex_indices\n"], "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "tokens": [], "softmax": []}