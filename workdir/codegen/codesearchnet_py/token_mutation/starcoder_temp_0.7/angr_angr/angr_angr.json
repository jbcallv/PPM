{"name": "angr_angr_VFG._widening_points", "language": "py", "prompt": "def _widening_points(self, function_address):\n        \"\"\"\n        Return the query widening points for a the function.\n\n        :param int function_address: Address of the querying function.\n        :return: A list of data merge points (addresses).\n        :rtype: list\n        \"\"\"", "tests": "", "completions": ["\n        return self._function_managers[function_address].widening_points\n\n    def _address_is_in_function(self, function_address, address):\n        \"\"\"\n        Check if the given address is inside the function.\n\n        :param int function_address: Address of the function.\n        :param int address: Address to check.\n        :return: True if the address is inside the function. False otherwise.\n        :rtype: bool\n        \"\"\"\n\n        func_start = self._function_managers[function_address].func_start\n        func_end = self._function_managers[function_address].func_end\n        return func_start <= address < func_end\n\n    def _function_address(self, address):\n        \"\"\"\n        Return the function address for the given address.\n\n        :param int address: Address to get function address for.\n        :return: Address of the function the address belongs to.\n        :rtype: int\n        \"\"\"\n        for function_address in self._function_managers:\n            if self._address_is_in_function(function_address, address):\n                return function_address\n\n        return None\n\n    def _function_manager(self, function_address):\n        \"\"\"\n        Return the function manager for the given function address.\n\n        :param int function_address: Address of the function.\n        :return: The function manager for the given function address.\n        :rtype: angr.knowledge.FunctionManager\n        \"\"\"\n        return self._function_managers[function_address]\n\n    def _function_cross_references(self, function_address):\n        \"\"\"\n        Return the function cross references for the given function address.\n\n        :param int function_address: Address of the function.\n        :return: The function cross references for the given function address.\n        :rtype: angr.knowledge.xrefs.FunctionXRefs\n        \"\"\"\n        return self._function_managers[function_address].function_cross_references\n\n    def _function_initial_state(self, function_address):\n        \"\"\"\n        Return the initial state of the given function address.\n\n        :param int function_address: Address of the function.\n        :return: The initial state of the given function address.\n        :rtype: SimState\n        \"\"\"\n        return self._function_managers[function_address].initial_state\n\n    def _function_return_sites(self, function_address):\n        \"\"\"\n        Return all return sites of the given function address.\n\n        :param int function"], "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "tokens": [], "softmax": []}