{"name": "numenta_nupic_SpatialPooler._updateInhibitionRadius", "language": "py", "prompt": "def _updateInhibitionRadius(self):\n    \"\"\"\n    Update the inhibition radius. The inhibition measure is a radius of the\n    square (or hypersquare) of columns that each a column is \"connected to\"\n    on average. Since columns are are not connected to each other directly, we\n    determine this quantity by first figuring out how many *inputs* a column is\n    connected to, and then multiplying it by the total number of columns that\n    exist for each input. For multiple dimension the aforementioned\n    calculations are averaged over all dimensions of inputs and columns. This\n    value is meaningless if no inhibition is enabled.\n    \"\"\"", "tests": "", "completions": ["\n    if self.inhibitionEnabled:\n      # Get inputs to columns, and convert to a list of unique inputs.\n      inputsToColumns = self.inhibitionInputsToColumns\n      if inputsToColumns is None:\n        inputsToColumns = self.inhibitionColumnsToInputs = {}\n      else:\n        self.inhibitionColumnsToInputs = {}\n      for column, inputs in inputsToColumns.items():\n        for input in inputs:\n          inputsToColumns[column].append(input)\n      uniqueInputs = list(set(itertools.chain(*inputsToColumns.values())))\n\n      # Count how many times each unique input is connected to a column.\n      inputCounts = collections.Counter()\n      for input in uniqueInputs:\n        inputCounts[input] = len(inputsToColumns.get(input, []))\n\n      # Compute the mean number of columns connected to each unique input.\n      meanColumnCounts = sum(inputCounts.values()) / float(len(uniqueInputs))\n\n      # Determine how many columns are connected to each input.\n      columnCounts = {input: 0 for input in uniqueInputs}\n      for column, inputs in inputsToColumns.items():\n        for input in inputs:\n          columnCounts[input] += 1\n\n      # Compute the average number of columns connected to each input.\n      meanColumnCount = sum(columnCounts.values()) / float(len(inputsToColumns))\n\n      # Compute the average number of columns connected to each unique input.\n      meanInputCounts = sum(inputCounts.values()) / float(len(uniqueInputs))\n\n      # Compute the inhibition radius.\n      self.inhibitionRadius = (\n        (meanColumnCount - meanInputCounts) / meanInputCounts)\n    else:\n      self.inhibitionRadius = 0\n\n"], "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "tokens": [], "softmax": []}