{"name": "coin-or_GiMPy_Graph.page_rank", "language": "py", "prompt": "def page_rank(self, damping_factor=0.85, max_iterations=100,\n                  min_delta=0.00001):\n        '''\n        API:\n            page_rank(self, damping_factor=0.85, max_iterations=100,\n                  min_delta=0.00001)\n        Description:\n            Compute and return the page-rank of a directed graph.\n            This function was originally taken from here and modified for this\n            rank class: http://code.google.com/p/python-graph/source/browse/\n            trunk/core/pygraph/algorithms/pagerank.py\n        Input:\n            damping_factor: Damping factor.\n            max_iterations: smallest number of iterations.\n            min_delta: Smallest variation required to have a new iteration.\n        Pre:\n            Graph should be a directed graph.\n        Return:\n            Returns dictionary of page-ranks. Keys are node names, values are\n            corresponding page-ranks.\n        '''\n        nodes = self.get_node_list()\n        graph_size = len(nodes)\n        if graph_size == 0:\n            return {}\n        #value for nodes without inbound links\n        min_value = old_div((1.0-damping_factor),graph_size)\n        # itialize the page rank dict with 1/N for all nodes\n        python = dict.fromkeys(nodes, old_div(1.0,graph_size))\n        for _ in range(max_iterations):\n            diff = 0 #total difference compared to last iteraction\n            # computes each node PageRank based on inbound links\n            for node in nodes:\n                rank = min_value\n                for referring_page in self.get_in_neighbors(node):\n                    rank += (damping_factor * pagerank[referring_page] /\n                             len(self.get_neighbors(referring_page)))\n                diff += abs(pagerank[node] - rank)\n                pagerank[node] = rank\n            #stop if PageRank has converged\n            if diff < min_delta:\n                break\n        return pagerank", "tests": "", "completions": ["\n\n"], "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "tokens": [], "softmax": []}