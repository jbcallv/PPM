{"name": "mwickert_scikit-dsp-comm_QPSK_rx", "language": "py", "prompt": "def QPSK_rx(fc,N_symb,Rs,EsN0=100,fs=125,lfsr_len=10,phase=0,pulse='src'):\n    \"\"\"\n    This thing generates\n    \"\"\"", "tests": "", "completions": ["\n    # Predefine variables\n    fs = fs #sampling frequency\n    N_symb = N_symb # number of symbols in the burst\n    Ts = 1/fs #sampling period\n    pulse_len = 10e-6 # pulse length\n    t_pulse = np.arange(0,pulse_len,Ts)\n    symbol_len = pulse_len/N_symb # symbol length\n    t_symbol = np.arange(0,symbol_len,Ts)\n    Es = EsN0*np.sqrt(2) #signal power\n\n    if pulse=='src':\n        pulse = src(t_pulse,fc)\n    else:\n        pulse = np.ones(len(t_pulse))\n\n    # Initiate variables\n    Rx = np.zeros(len(t_pulse)) # Received signal\n    x_lsf = np.zeros(len(t_pulse)) # LSF of x\n    x_lsf_symb = np.zeros(len(t_symbol)) # LSF of x\n\n    # Loop over symbols\n    for i in range(N_symb):\n        # Generate a random sequence\n        rand_seq = np.random.randint(0,2,lfsr_len)\n\n        # Create LSF of random sequence\n        x_lsf_symb = np.convolve(rand_seq,pulse,'full')[:len(t_symbol)]\n\n        # Multiply it with the pulse to get the LSF of the received signal\n        x_lsf = np.convolve(x_lsf_symb,pulse)[:len(t_pulse)]\n\n        # Apply the LSF to the received signal\n        Rx = np.convolve(Rx,x_lsf)[:len(t_pulse)]\n\n        # Add noise\n        Rx = Rx + np.random.normal(0,np.sqrt(Es/2),len(t_pulse))\n\n    return Rx\n"], "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "tokens": [], "softmax": []}