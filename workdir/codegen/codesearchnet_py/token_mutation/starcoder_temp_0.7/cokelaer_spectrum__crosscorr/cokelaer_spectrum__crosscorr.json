{"name": "cokelaer_spectrum__crosscorr", "language": "py", "prompt": "def _crosscorr(x, y, **kwargs):\n    \"\"\"\n    Returns the crosscorrelation sequence between two ndarrays.\n    This is performed by calling fftconvolve on x, y[::-1]\n\n    Parameters\n\n\n    x: ndarray\n    y: ndarray\n    axis: time axis\n    all_lags: {True/False}\n    whether to return all _ lags, or to clip the length of r_xy\n    to be the length of x and y. If False, then the zero lag correlation\n    is at index 0. Otherwise, it is found at (len(x) + len(y) - 1)/2\n\n    Notes\n\n\n    this correlation is defined as\n    rxy[k] := E{X[t]*Y[t+k]}/(E{X*X}E{Y*Y})**.5,\n    where X,Y are zero mean random processes. It is the zero cross\n    covariance.\n    \"\"\"", "tests": "", "completions": ["\n    if x.ndim == 1:\n        x = x[:, np.newaxis]\n    if y.ndim == 1:\n        y = y[:, np.newaxis]\n    assert x.ndim == y.ndim == 2\n    Nx = x.shape[1]\n    Ny = y.shape[1]\n\n    rxy = fftconvolve(x, np.flipud(y), **kwargs)\n    rxy /= np.sqrt(fftconvolve(x ** 2, y ** 2, **kwargs))\n\n    if kwargs.get(\"all_lags\", False):\n        return rxy\n    else:\n        return rxy[(Nx + Ny - 1) // 2 + 1 :]\n"], "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "tokens": [], "softmax": []}