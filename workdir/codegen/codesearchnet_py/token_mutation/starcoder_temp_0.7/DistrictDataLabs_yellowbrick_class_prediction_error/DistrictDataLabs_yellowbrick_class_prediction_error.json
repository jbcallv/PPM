{"name": "DistrictDataLabs_yellowbrick_class_prediction_error", "language": "py", "prompt": "def class_prediction_error(\n    model,\n    X,\n    y=None,\n    ax=None,\n    classes=None,\n    test_size=0.2,\n    random_state=None,\n    **kwargs):\n    \"\"\"Quick method:\n    Divides the dataset X and y into train and test splits, fits the model on\n    the train split, then scores the model on the test split. The visualizer\n    displays the support for each class in the fitted classification model\n    displayed as a stacked bar plot Each segment is segmented to show the\n    distribution of predicted classes for each class.\n\n    This helper function is a quick wrapper to utilize the ClassPredictionError\n    function for one-off analysis.\n\n    Parameters\n    ----------\n    model : the Scikit-Learn estimator (should be a classifier)\n\n    X  : ndarray or DataFrame of shape n x m\n        A matrix of n instances with m features.\n\n    y  : ndarray or Series of length n\n        An array or series of target or class values.\n\n    ax : matplotlib axes\n        The axes to plot the figure on.\n\n    classes : list of strings\n        The names of the classes in the target\n\n    test_size : float, default=0.2\n        The percentage of the data to reserve as input data.\n\n    random_state : int or None, default=None\n        The value to seed the random number generator for shuffling data.\n\n    Returns\n    -------\n    ax : matplotlib axes\n        Returns the axes that the class prediction error plot was drawn on.\n    \"\"\"", "tests": "", "completions": ["\n    cpv = ClassPredictionError(model, classes, ax=ax, **kwargs)\n    cpv.fit(X, y)\n    cpv.score(X, y, test_size=test_size, random_state=random_state)\n    return cpv.ax\n"], "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "tokens": [], "softmax": []}