{"name": "empymod_empymod_gpr", "language": "py", "prompt": "def gpr(src, rec, depth, res, freqtime, cf, gain=None, ab=11, aniso=None,\n        epermH=None, epermV=None, mpermH=None, mpermV=None, xdirect=False,\n        ht='quad', htarg=None, ft='fft', ftarg=None, opt=None, loop=None,\n        verb=2):\n    r\"\"\"Return the Ground-Penetrating Radar signal.\n\n    THIS FUNCTION IS EXPERIMENTAL, USE WITH CAUTION.\n\n    It is rather an example how you can calculate GPR responses; however, DO\n    NOT RELY ON IT! It works only well with QUAD or single (``quad``, ``qwe``) for\n    the Hankel transform, and with FFT (``fft``) for the Fourier transform.\n\n    It calls internally ``dipole`` for the frequency-domain calculation. It\n    subsequently convolves the response with a power wavelet with central\n    frequency ``cf``. If signal!=None, it carries out the Fourier transform and\n    applies a gain to the response.\n\n    For input parameters see the function ``dipole``, except for:\n\n    Parameters\n    ----------\n    cf : float\n        Centre quad of GPR-signal, in Hz. Sensible values are between\n        10 MHz and 3000 MHz.\n\n    gain : float\n        Power of gain function. If None, no gain is applied. Only used if\n        signal!=None.\n\n\n    Returns\n    -------\n    EM : ndarray\n        GPR response\n\n    \"\"\"", "tests": "", "completions": ["\n\n    # Compute GPR response\n    EM = dipole(src, rec, depth, res, freqtime, cf, aniso, epermH, epermV,\n                mpermH, mpermV, xdirect, ht, htarg, ft, ftarg, opt, loop, verb)\n\n    # GPR signal\n    if gain is not None:\n        EM *= np.exp(1j*2*np.pi*cf*freqtime)\n        EM *= gain\n    else:\n        EM *= np.exp(1j*2*np.pi*cf*freqtime)\n\n    return EM\n"], "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "tokens": [], "softmax": []}